// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.8.0 <0.9.0;
import "@openzeppelin/contracts/access/Ownable.sol";
import "hardhat/console.sol";

/**
 * @title Ballot
 */
contract Ballot is Ownable {

    struct Candidate {
        string name;
        address wallet;
    }

    struct Vote {
        string name;
        bool withdrawStatus;        // false: none, true: to winnner
        bool isFinished;
        uint256 startTime;
        address[] voterList;
        uint256 candidateCount;
        mapping (uint256 => Candidate) candidateMap;
        mapping (address => uint256) voterCandidateMap;     // candidate number+1
        mapping (uint256 => uint256) candidateScore;
    }

    uint256 voteTime = 3 days;
    uint256 feePercent = 10;    // 10%
    uint256 feeTotal;
    address adminWallet;

    mapping (uint256 => Vote) voteMap;
    uint256 voteCount;
    uint256 voteFee = 0.001 ether;

    modifier isValidVote (uint256 _vNum) {
        require(_vNum < voteCount, "Vote# is over");
        _;
    }

    modifier isValidCandidate (uint256 _vNum, uint256 _cNum) {
        require(_vNum < voteCount, "Vote# is over");
        require(_cNum < voteMap[_vNum].candidateCount, "Candidate# is over");
        _;
    }

    constructor () {

    }

    function createVote(string memory _name, uint256 _startTime) public onlyOwner returns (uint256) {
        Vote storage newVote = voteMap[voteCount];
        newVote.name = _name;
        newVote.startTime = _startTime;
        console.log(voteCount);
        return voteCount++;
    }

    function addCandidate(uint256 _vNum, string memory _cName, address _cWallet) public onlyOwner isValidVote(_vNum) returns (uint256) {
        uint256 candidateCount = voteMap[_vNum].candidateCount++;
        voteMap[_vNum].candidateMap[candidateCount] = Candidate(_cName, _cWallet);
        console.log(candidateCount);
        return candidateCount;
    }

    function setCandidate(uint256 _vNum, uint256 _cNum, string memory _cName, address _cWallet) public isValidCandidate(_vNum, _cNum) onlyOwner {
        voteMap[_vNum].candidateMap[_cNum].name = _cName;
        voteMap[_vNum].candidateMap[_cNum].wallet = _cWallet;
    }

    function vote(uint256 _vNum, uint256 _cNum) external payable isValidCandidate(_vNum, _cNum) returns (uint256, uint256) {
        require(msg.sender != address(0));
        require(voteMap[_vNum].isFinished, "Vote was already finished");
        require(msg.value >= voteFee , "Vote Fee is not enough");
        require(voteMap[_vNum].voterCandidateMap[msg.sender] > 0, "Sender already voted");

        voteMap[_vNum].voterCandidateMap[msg.sender] = _cNum + 1;
        voteMap[_vNum].candidateScore[_cNum]++;
        voteMap[_vNum].voterList.push(msg.sender);

        // emit Mint(msg.sender, mintStep, mintPrice[mintStep], _mintCount, _tokenId);
        
        return (_vNum, _cNum);
    }

    function finishVote(uint256 _vNum) public isValidVote(_vNum) returns (bool) {
        require(voteMap[_vNum].startTime + voteTime <= block.timestamp, "Check the vote time");
        voteMap[_vNum].isFinished = true;

        return withdraw(_vNum);
    }

    function withdraw(uint256 _vNum) internal isValidVote(_vNum) returns (bool) {
        require(voteMap[_vNum].withdrawStatus, "Reward was already withdrawn to winner");

        uint256 reward = voteFee * voteMap[_vNum].candidateCount / 100 * (100 - feePercent);
        address winnerWallet = voteMap[_vNum].candidateMap[getWinnerId(_vNum)].wallet;
        (bool success, ) = winnerWallet.call{value: reward}("");
        require(success, string(abi.encodePacked("Failed to send to ", winnerWallet)));

        voteMap[_vNum].withdrawStatus = success;
        feeTotal += voteFee * voteMap[_vNum].candidateCount / 100 * feePercent;

        return success;
    }

    function withdrawFee() public onlyOwner {
        (bool success, ) = adminWallet.call{value: feeTotal}("");
        require(success, string(abi.encodePacked("Failed to send to ", adminWallet)));
    }

    function getWinnerId(uint256 _vNum) public view isValidVote(_vNum) returns (uint256) {
        uint256 id;
        uint256 max;
        for (uint256 i = 0; i < voteMap[_vNum].candidateCount; i++) {
            if (max < voteMap[_vNum].candidateScore[i]) {
                id = i;
                max = voteMap[_vNum].candidateScore[i];
            }
        }
        return id;
    }

    function getVoteInfo(uint256 _vNum) public view isValidVote(_vNum) returns (string memory, bool, bool, uint256, uint256) {
        return (voteMap[_vNum].name, voteMap[_vNum].isFinished, voteMap[_vNum].withdrawStatus, voteMap[_vNum].candidateCount, voteMap[_vNum].voterList.length);
    }

    function getVoterList(uint256 _vNum) public view isValidVote(_vNum) returns (address[] memory) {
        return (voteMap[_vNum].voterList);
    }

    function getCandidateList(uint256 _vNum) public view isValidVote(_vNum) returns (Candidate[] memory) {
        uint256 count = voteMap[_vNum].candidateCount;
        Candidate[] memory result = new Candidate[](count);

        console.log(count);

        if (count == 0)
            return result;

        for (uint256 i = 0; i < count; i++)
            result[i] = voteMap[_vNum].candidateMap[i];

        return result;
    }

    function getCandidateScoreList(uint256 _vNum) public view isValidVote(_vNum) returns (uint256[] memory) {
        uint256[] memory scoreList = new uint256[](voteMap[_vNum].candidateCount);
        for (uint256 i = 0; i < scoreList.length; i++)
            scoreList[i] = voteMap[_vNum].candidateScore[i];
        return scoreList;
    }
    
    function getVoterCandidateMatch(uint256 _vNum) public view isValidVote(_vNum) returns(address[] memory, uint256[] memory) {
        uint256[] memory toCandidateList = new uint256[](voteMap[_vNum].voterList.length);

        for (uint256 i = 0; i < voteMap[_vNum].voterList.length; i++)
            toCandidateList[i] = voteMap[_vNum].voterCandidateMap[voteMap[_vNum].voterList[i]]-1;

        return (voteMap[_vNum].voterList, toCandidateList);
    }
}